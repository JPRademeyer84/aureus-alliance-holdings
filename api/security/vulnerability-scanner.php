<?php
/**
 * VULNERABILITY SCANNER
 * Automated vulnerability detection and assessment system
 */

require_once '../config/cors.php';
require_once '../config/secure-session.php';
require_once '../config/security-logger.php';

// Handle CORS and preflight requests
handlePreflight();
setCorsHeaders();

// Start secure session
SecureSession::start();

// Check admin authentication
if (!isset($_SESSION['admin_id'])) {
    http_response_code(401);
    echo json_encode(['error' => 'Admin authentication required']);
    exit;
}

$method = $_SERVER['REQUEST_METHOD'];
$action = $_GET['action'] ?? 'scan';

try {
    switch ($action) {
        case 'scan':
            performVulnerabilityScan();
            break;
            
        case 'report':
            getVulnerabilityReport();
            break;
            
        case 'history':
            getScanHistory();
            break;
            
        default:
            http_response_code(400);
            echo json_encode(['error' => 'Invalid action']);
            exit;
    }
    
} catch (Exception $e) {
    error_log("Vulnerability scanner error: " . $e->getMessage());
    http_response_code(500);
    echo json_encode(['error' => 'Scanner failed: ' . $e->getMessage()]);
}

/**
 * Perform comprehensive vulnerability scan
 */
function performVulnerabilityScan() {
    $scanId = bin2hex(random_bytes(16));
    $startTime = microtime(true);
    
    $scanResults = [
        'scan_id' => $scanId,
        'scan_type' => 'comprehensive',
        'start_time' => date('c'),
        'scanned_by' => $_SESSION['admin_id'],
        'vulnerabilities' => []
    ];
    
    // 1. File System Vulnerabilities
    $fileSystemVulns = scanFileSystemVulnerabilities();
    $scanResults['vulnerabilities'] = array_merge($scanResults['vulnerabilities'], $fileSystemVulns);
    
    // 2. Configuration Vulnerabilities
    $configVulns = scanConfigurationVulnerabilities();
    $scanResults['vulnerabilities'] = array_merge($scanResults['vulnerabilities'], $configVulns);
    
    // 3. Database Vulnerabilities
    $databaseVulns = scanDatabaseVulnerabilities();
    $scanResults['vulnerabilities'] = array_merge($scanResults['vulnerabilities'], $databaseVulns);
    
    // 4. Web Application Vulnerabilities
    $webAppVulns = scanWebApplicationVulnerabilities();
    $scanResults['vulnerabilities'] = array_merge($scanResults['vulnerabilities'], $webAppVulns);
    
    // 5. API Security Vulnerabilities
    $apiVulns = scanAPIVulnerabilities();
    $scanResults['vulnerabilities'] = array_merge($scanResults['vulnerabilities'], $apiVulns);
    
    // 6. Authentication & Authorization Vulnerabilities
    $authVulns = scanAuthenticationVulnerabilities();
    $scanResults['vulnerabilities'] = array_merge($scanResults['vulnerabilities'], $authVulns);
    
    // 7. Cryptographic Vulnerabilities
    $cryptoVulns = scanCryptographicVulnerabilities();
    $scanResults['vulnerabilities'] = array_merge($scanResults['vulnerabilities'], $cryptoVulns);
    
    // 8. Infrastructure Vulnerabilities
    $infraVulns = scanInfrastructureVulnerabilities();
    $scanResults['vulnerabilities'] = array_merge($scanResults['vulnerabilities'], $infraVulns);
    
    $executionTime = round((microtime(true) - $startTime) * 1000);
    $scanResults['execution_time_ms'] = $executionTime;
    $scanResults['end_time'] = date('c');
    
    // Categorize vulnerabilities by severity
    $severityCounts = categorizeBySeverity($scanResults['vulnerabilities']);
    $scanResults['summary'] = [
        'total_vulnerabilities' => count($scanResults['vulnerabilities']),
        'critical' => $severityCounts['critical'],
        'high' => $severityCounts['high'],
        'medium' => $severityCounts['medium'],
        'low' => $severityCounts['low'],
        'risk_score' => calculateRiskScore($severityCounts)
    ];
    
    // Store scan results
    storeScanResults($scanResults);
    
    // Log scan completion
    logSecurityEvent(SecurityLogger::EVENT_SYSTEM, 'vulnerability_scan_completed', SecurityLogger::LEVEL_INFO,
        'Vulnerability scan completed', [
            'scan_id' => $scanId,
            'vulnerabilities_found' => count($scanResults['vulnerabilities']),
            'execution_time_ms' => $executionTime,
            'risk_score' => $scanResults['summary']['risk_score']
        ]);
    
    echo json_encode([
        'success' => true,
        'scan_results' => $scanResults
    ], JSON_PRETTY_PRINT);
}

/**
 * Scan file system vulnerabilities
 */
function scanFileSystemVulnerabilities() {
    $vulnerabilities = [];
    $apiDir = dirname(__DIR__);
    
    // Check for sensitive files
    $sensitiveFiles = [
        '.env',
        'config.php',
        'database.php',
        '.htaccess',
        'composer.json',
        'package.json'
    ];
    
    foreach ($sensitiveFiles as $file) {
        $filePath = $apiDir . '/' . $file;
        if (file_exists($filePath)) {
            $permissions = fileperms($filePath);
            $isWorldReadable = ($permissions & 0x0004);
            $isWorldWritable = ($permissions & 0x0002);
            
            if ($isWorldReadable || $isWorldWritable) {
                $vulnerabilities[] = [
                    'type' => 'file_permissions',
                    'severity' => $isWorldWritable ? 'critical' : 'high',
                    'file' => $file,
                    'description' => "Sensitive file has insecure permissions",
                    'permissions' => sprintf('%o', $permissions),
                    'recommendation' => 'Set file permissions to 600 or 644'
                ];
            }
        }
    }
    
    // Check for backup files
    $backupPatterns = ['*.bak', '*.backup', '*.old', '*.tmp', '*~'];
    foreach ($backupPatterns as $pattern) {
        $backupFiles = glob($apiDir . '/' . $pattern);
        foreach ($backupFiles as $backupFile) {
            $vulnerabilities[] = [
                'type' => 'backup_file_exposure',
                'severity' => 'medium',
                'file' => basename($backupFile),
                'description' => 'Backup file may contain sensitive information',
                'recommendation' => 'Remove backup files from web-accessible directories'
            ];
        }
    }
    
    // Check for directory listing
    $directories = ['uploads', 'assets', 'logs'];
    foreach ($directories as $dir) {
        $dirPath = $apiDir . '/' . $dir;
        if (is_dir($dirPath) && !file_exists($dirPath . '/index.php') && !file_exists($dirPath . '/.htaccess')) {
            $vulnerabilities[] = [
                'type' => 'directory_listing',
                'severity' => 'medium',
                'directory' => $dir,
                'description' => 'Directory listing may be enabled',
                'recommendation' => 'Add index.php or .htaccess to prevent directory listing'
            ];
        }
    }
    
    return $vulnerabilities;
}

/**
 * Scan configuration vulnerabilities
 */
function scanConfigurationVulnerabilities() {
    $vulnerabilities = [];
    
    // Check PHP configuration
    $phpVulns = checkPHPConfiguration();
    $vulnerabilities = array_merge($vulnerabilities, $phpVulns);
    
    // Check web server configuration
    $webServerVulns = checkWebServerConfiguration();
    $vulnerabilities = array_merge($vulnerabilities, $webServerVulns);
    
    // Check security headers
    $headerVulns = checkSecurityHeaders();
    $vulnerabilities = array_merge($vulnerabilities, $headerVulns);
    
    return $vulnerabilities;
}

/**
 * Check PHP configuration
 */
function checkPHPConfiguration() {
    $vulnerabilities = [];
    
    // Check dangerous PHP settings
    $dangerousSettings = [
        'allow_url_fopen' => 'Should be disabled to prevent remote file inclusion',
        'allow_url_include' => 'Should be disabled to prevent remote code execution',
        'register_globals' => 'Should be disabled (deprecated)',
        'magic_quotes_gpc' => 'Should be disabled (deprecated)',
        'display_errors' => 'Should be disabled in production'
    ];
    
    foreach ($dangerousSettings as $setting => $recommendation) {
        if (ini_get($setting)) {
            $vulnerabilities[] = [
                'type' => 'php_configuration',
                'severity' => 'high',
                'setting' => $setting,
                'current_value' => ini_get($setting),
                'description' => "Dangerous PHP setting enabled: $setting",
                'recommendation' => $recommendation
            ];
        }
    }
    
    // Check if expose_php is enabled
    if (ini_get('expose_php')) {
        $vulnerabilities[] = [
            'type' => 'information_disclosure',
            'severity' => 'low',
            'setting' => 'expose_php',
            'description' => 'PHP version exposed in headers',
            'recommendation' => 'Disable expose_php to hide PHP version'
        ];
    }
    
    return $vulnerabilities;
}

/**
 * Check web server configuration
 */
function checkWebServerConfiguration() {
    $vulnerabilities = [];
    
    // Check server signature
    $serverHeader = $_SERVER['SERVER_SOFTWARE'] ?? '';
    if (!empty($serverHeader)) {
        $vulnerabilities[] = [
            'type' => 'information_disclosure',
            'severity' => 'low',
            'header' => 'Server',
            'value' => $serverHeader,
            'description' => 'Server information exposed in headers',
            'recommendation' => 'Configure server to hide version information'
        ];
    }
    
    return $vulnerabilities;
}

/**
 * Check security headers
 */
function checkSecurityHeaders() {
    $vulnerabilities = [];
    
    $requiredHeaders = [
        'X-Content-Type-Options' => 'nosniff',
        'X-Frame-Options' => 'DENY',
        'X-XSS-Protection' => '1; mode=block',
        'Strict-Transport-Security' => 'max-age=31536000',
        'Content-Security-Policy' => 'default-src \'self\''
    ];
    
    // Simulate header check (in production, make actual HTTP request)
    $currentHeaders = getallheaders();
    
    foreach ($requiredHeaders as $header => $expectedValue) {
        if (!isset($currentHeaders[$header])) {
            $vulnerabilities[] = [
                'type' => 'missing_security_header',
                'severity' => 'medium',
                'header' => $header,
                'description' => "Missing security header: $header",
                'recommendation' => "Add $header header with value: $expectedValue"
            ];
        }
    }
    
    return $vulnerabilities;
}

/**
 * Scan database vulnerabilities
 */
function scanDatabaseVulnerabilities() {
    $vulnerabilities = [];
    
    try {
        $database = new Database();
        $db = $database->getConnection();
        
        if ($db) {
            // Check for default credentials
            $defaultCredVulns = checkDefaultDatabaseCredentials($db);
            $vulnerabilities = array_merge($vulnerabilities, $defaultCredVulns);
            
            // Check database permissions
            $permissionVulns = checkDatabasePermissions($db);
            $vulnerabilities = array_merge($vulnerabilities, $permissionVulns);
            
            // Check for SQL injection vulnerabilities
            $sqlInjectionVulns = checkSQLInjectionVulnerabilities($db);
            $vulnerabilities = array_merge($vulnerabilities, $sqlInjectionVulns);
        }
        
    } catch (Exception $e) {
        $vulnerabilities[] = [
            'type' => 'database_connection',
            'severity' => 'high',
            'description' => 'Database connection error: ' . $e->getMessage(),
            'recommendation' => 'Check database configuration and connectivity'
        ];
    }
    
    return $vulnerabilities;
}

/**
 * Scan web application vulnerabilities
 */
function scanWebApplicationVulnerabilities() {
    $vulnerabilities = [];
    
    // Check for common web vulnerabilities
    $webVulns = [
        'xss' => checkXSSVulnerabilities(),
        'csrf' => checkCSRFVulnerabilities(),
        'session' => checkSessionVulnerabilities(),
        'upload' => checkFileUploadVulnerabilities()
    ];
    
    foreach ($webVulns as $category => $vulns) {
        $vulnerabilities = array_merge($vulnerabilities, $vulns);
    }
    
    return $vulnerabilities;
}

/**
 * Scan API vulnerabilities
 */
function scanAPIVulnerabilities() {
    $vulnerabilities = [];
    
    // Check API endpoints
    $apiEndpoints = [
        '/api/admin/',
        '/api/user/',
        '/api/financial/',
        '/api/security/'
    ];
    
    foreach ($apiEndpoints as $endpoint) {
        $endpointVulns = checkAPIEndpointSecurity($endpoint);
        $vulnerabilities = array_merge($vulnerabilities, $endpointVulns);
    }
    
    return $vulnerabilities;
}

/**
 * Helper functions
 */

function checkDefaultDatabaseCredentials($db) {
    $vulnerabilities = [];
    
    // Check for common default credentials
    $defaultCreds = [
        ['root', ''],
        ['admin', 'admin'],
        ['test', 'test']
    ];
    
    // This is a simplified check - in production, implement proper credential testing
    return $vulnerabilities;
}

function checkDatabasePermissions($db) {
    $vulnerabilities = [];
    
    try {
        // Check current user privileges
        $stmt = $db->query("SHOW GRANTS");
        $grants = $stmt->fetchAll();
        
        foreach ($grants as $grant) {
            $grantText = $grant[0];
            if (strpos($grantText, 'ALL PRIVILEGES') !== false) {
                $vulnerabilities[] = [
                    'type' => 'excessive_database_privileges',
                    'severity' => 'high',
                    'description' => 'Database user has ALL PRIVILEGES',
                    'grant' => $grantText,
                    'recommendation' => 'Use principle of least privilege for database access'
                ];
            }
        }
        
    } catch (Exception $e) {
        // Handle permission check error
    }
    
    return $vulnerabilities;
}

function checkSQLInjectionVulnerabilities($db) {
    $vulnerabilities = [];
    
    // This would involve testing various SQL injection payloads
    // Simplified implementation for demonstration
    
    return $vulnerabilities;
}

function checkXSSVulnerabilities() {
    $vulnerabilities = [];
    
    // Check for XSS vulnerabilities in forms and parameters
    // Simplified implementation
    
    return $vulnerabilities;
}

function checkCSRFVulnerabilities() {
    $vulnerabilities = [];
    
    // Check for CSRF protection
    // Simplified implementation
    
    return $vulnerabilities;
}

function checkSessionVulnerabilities() {
    $vulnerabilities = [];
    
    // Check session configuration
    if (!ini_get('session.cookie_httponly')) {
        $vulnerabilities[] = [
            'type' => 'session_security',
            'severity' => 'medium',
            'setting' => 'session.cookie_httponly',
            'description' => 'Session cookies not set to HttpOnly',
            'recommendation' => 'Enable session.cookie_httponly'
        ];
    }
    
    if (!ini_get('session.cookie_secure')) {
        $vulnerabilities[] = [
            'type' => 'session_security',
            'severity' => 'medium',
            'setting' => 'session.cookie_secure',
            'description' => 'Session cookies not set to Secure',
            'recommendation' => 'Enable session.cookie_secure for HTTPS'
        ];
    }
    
    return $vulnerabilities;
}

function checkFileUploadVulnerabilities() {
    $vulnerabilities = [];
    
    // Check file upload security
    // Simplified implementation
    
    return $vulnerabilities;
}

function checkAPIEndpointSecurity($endpoint) {
    $vulnerabilities = [];
    
    // Check API endpoint security
    // Simplified implementation
    
    return $vulnerabilities;
}

function scanAuthenticationVulnerabilities() {
    return [];
}

function scanCryptographicVulnerabilities() {
    return [];
}

function scanInfrastructureVulnerabilities() {
    return [];
}

function categorizeBySeverity($vulnerabilities) {
    $counts = ['critical' => 0, 'high' => 0, 'medium' => 0, 'low' => 0];
    
    foreach ($vulnerabilities as $vuln) {
        $severity = $vuln['severity'] ?? 'low';
        if (isset($counts[$severity])) {
            $counts[$severity]++;
        }
    }
    
    return $counts;
}

function calculateRiskScore($severityCounts) {
    return ($severityCounts['critical'] * 25) + 
           ($severityCounts['high'] * 15) + 
           ($severityCounts['medium'] * 8) + 
           ($severityCounts['low'] * 3);
}

function storeScanResults($scanResults) {
    // Store scan results in database or file
    $resultsFile = dirname(__DIR__) . '/logs/vulnerability_scans.json';
    
    $existingResults = [];
    if (file_exists($resultsFile)) {
        $existingResults = json_decode(file_get_contents($resultsFile), true) ?: [];
    }
    
    $existingResults[] = $scanResults;
    
    // Keep only last 50 scans
    if (count($existingResults) > 50) {
        $existingResults = array_slice($existingResults, -50);
    }
    
    file_put_contents($resultsFile, json_encode($existingResults, JSON_PRETTY_PRINT));
}

function getVulnerabilityReport() {
    $resultsFile = dirname(__DIR__) . '/logs/vulnerability_scans.json';
    
    if (!file_exists($resultsFile)) {
        echo json_encode(['success' => false, 'error' => 'No scan results found']);
        return;
    }
    
    $scanResults = json_decode(file_get_contents($resultsFile), true);
    $latestScan = end($scanResults);
    
    echo json_encode([
        'success' => true,
        'latest_scan' => $latestScan,
        'scan_history_count' => count($scanResults)
    ]);
}

function getScanHistory() {
    $resultsFile = dirname(__DIR__) . '/logs/vulnerability_scans.json';
    
    if (!file_exists($resultsFile)) {
        echo json_encode(['success' => false, 'error' => 'No scan history found']);
        return;
    }
    
    $scanResults = json_decode(file_get_contents($resultsFile), true);
    
    // Return summary of all scans
    $history = [];
    foreach ($scanResults as $scan) {
        $history[] = [
            'scan_id' => $scan['scan_id'],
            'scan_date' => $scan['start_time'],
            'vulnerabilities_found' => $scan['summary']['total_vulnerabilities'],
            'risk_score' => $scan['summary']['risk_score'],
            'execution_time_ms' => $scan['execution_time_ms']
        ];
    }
    
    echo json_encode([
        'success' => true,
        'scan_history' => $history
    ]);
}
?>
